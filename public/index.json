
[{"content":"","date":"30 November 2025","externalUrl":null,"permalink":"/","section":"","summary":"","title":"","type":"page"},{"content":"","date":"30 November 2025","externalUrl":null,"permalink":"/projects/","section":"","summary":"","title":"","type":"projects"},{"content":" For education # In the last year of my degree, I was introduced to modern control systems. Naturally, courses have to be rushed to get through as much of the content as possible; I wasn\u0026rsquo;t satisfied with my understanding of the material. Over the summer of 2024 to 2025, I decided to work on a project that would improve my understanding of linear control systems, or at least give me a platform that I could experiment with. A balancing apparatus would be perfect as a project. In fact, one of the most common control systems projects is a linear inverted pendulum:\nDiagram of a linear inverted pendulum. A cart is moved in one axis to balance a pendulum vertically. This is similar to balancing a pencil vertically on your finger. But given that my workspace is small and the linear inverted pendulum requires many more parts, a rotary inverted pendulum was more appropriate:\nA rotating inverted pendulum from wikipedia Unlike the linear variant, a rotary inverted pendulum rotates the base instead of moving it horizontally, making it much more compact. No need for pulleys, chassis or extra space. The base can be simply rotated directly via a motor or through gearing.\nDemonstration # Your browser does not support the video tag. My rotary inverted pendulum project in action. Apologies for the bad lighting and quality. I was using a camera from the 2000s and my ring light wasn\u0026rsquo;t bright enough. But it definitely gives it a vibe. The mechanical side of the build is simple. A motor drives a vertical shaft connected to a flange, which then links to a horizontal shaft and the pendulum:\nSimplified diagram of the rotary inverted pendulum. The rig needs a rigid 90 degree connection between the horizontal shaft and the pendulum. Since I couldn\u0026rsquo;t find a shaft with a fixed right-angle bend, I used a universal joint coupler instead:\nAn example of the universal joint coupler I am using. These couplers are free to swivel as they rotate, which would cause the pendulum to bend in this manner:\nBent pendulum angle. This is undesirable, so I ziptied the pendulum and horizontal shaft together.\nRegarding the electronics, I used a stepper motor driven by a stepper driver. An Arduino Uno controls the stepper driver and processes the control algorithm. In addition, the rotary encoder is read directly by the Arduino Uno.\nBill of Materials # The total cost of the project, including electronics, summed to 142.44 NZD.\nMechanical # Item Quantity Cost (NZD) Source Linear Shaft, 150mm length, 5mm diameter 1 $4.17 Aliexpress Rigid Shaft Coupler, 5mm to 5mm 1 $4.79 Aliexpress Rigid Shaft Coupler, 4mm to 6mm 1 $4.46 Aliexpress Universal Shaft Joint Coupler, 4mm to 4mm 1 $3.53 Aliexpress Rotary Encoder Mounting Bracket 1 $27.74 Aliexpress Linear Shaft, 125mm length, 4mm diameter 2 (from 5pcs set) $7.36 Aliexpress Rigid Flange Coupler, 5mm 1 (from 3pcs set) $14.94 BigFace Electronics # Item Quantity Cost (NZD) Source Incremental Rotary Encoder 38S6G5-B-G24N 1000ppr 1 $26.34 Aliexpress Stepper Motor Nema 17 17HE19-2004S 1 $27.41 Aliexpress Stepper Motor Driver TMC2209 1 $5.87 Aliexpress 1 Arduino Uno 1 $20 ? 2 Notes # I couldn't get the UART communication working but the STEP/DIR functionality worked just fine, which is all I needed. I reused an Arduino Uno I bought a long time ago, so the price is estimated. ","date":"30 November 2025","externalUrl":null,"permalink":"/projects/rotary_inverted_pendulum/","section":"","summary":"","title":"A custom rotary inverted pendulum","type":"project"},{"content":"","date":"30 November 2025","externalUrl":null,"permalink":"/tags/arduino/","section":"Tags","summary":"","title":"Arduino","type":"tags"},{"content":"","date":"30 November 2025","externalUrl":null,"permalink":"/tags/c++/","section":"Tags","summary":"","title":"C++","type":"tags"},{"content":"","date":"30 November 2025","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"30 November 2025","externalUrl":null,"permalink":"/tags/control-systems/","section":"Tags","summary":"","title":"Control Systems","type":"tags"},{"content":"","date":"30 November 2025","externalUrl":null,"permalink":"/tags/embedded-systems/","section":"Tags","summary":"","title":"Embedded Systems","type":"tags"},{"content":"","date":"30 November 2025","externalUrl":null,"permalink":"/tags/lqr/","section":"Tags","summary":"","title":"LQR","type":"tags"},{"content":"","date":"30 November 2025","externalUrl":null,"permalink":"/tags/mathematical-modelling/","section":"Tags","summary":"","title":"Mathematical Modelling","type":"tags"},{"content":"","date":"30 November 2025","externalUrl":null,"permalink":"/tags/practical/","section":"Tags","summary":"","title":"Practical","type":"tags"},{"content":"","date":"30 November 2025","externalUrl":null,"permalink":"/tags/python/","section":"Tags","summary":"","title":"Python","type":"tags"},{"content":"","date":"30 November 2025","externalUrl":null,"permalink":"/categories/showcase/","section":"Categories","summary":"","title":"Showcase","type":"categories"},{"content":"","date":"30 November 2025","externalUrl":null,"permalink":"/tags/stability/","section":"Tags","summary":"","title":"Stability","type":"tags"},{"content":"","date":"30 November 2025","externalUrl":null,"permalink":"/tags/stepper-motor/","section":"Tags","summary":"","title":"Stepper Motor","type":"tags"},{"content":"","date":"30 November 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"29 November 2025","externalUrl":null,"permalink":"/articles/","section":"","summary":"","title":"","type":"articles"},{"content":" A side objective # A few months ago, I developed a framework to learn about good software architecture design in C++ for simulations. As a test case, I chose 2D diffusion. One simulation used random walkers, while another used the discretised version of the diffusion equation. Two fundamentally different simulation methods, yet they model the same phenomenon. Understanding why this is the case is an interesting topic in itself, and worthy of its own post.\nThe simulation framework # Your browser does not support the video tag. The above video is the output of the 2D diffusion simulation framework using random walkers. Each red pixel is a random walker. The greater the concentration of walkers, the redder the pixel.\nA random walker is a particle set to move in a random direction at every time step. In this simulation, each walker moves independently, with equal probability in every direction.\nThis approach belongs to a broader category of techniques known as Monte Carlo methods. These methods use randomness to approximate what could be solved deterministically. In this case, instead of using the diffusion equation directly, we get diffusion through the statistical output of many random walkers.\nContrast this with the video below. Your browser does not support the video tag. This output comes from numerically solving the diffusion equation:\n$$ \\frac{\\partial \\rho}{\\partial t} = D \\left( \\frac{\\partial^2 \\rho}{\\partial x^2} + \\frac{\\partial^2 \\rho}{\\partial y^2} \\right) $$where \\(D\\) is the diffusion coefficient, and \\(\\rho\\) is the concentration at point \\((x, y)\\) for a given time \\(t\\).\nRather than moving particles randomly, the same system is represented as a grid of concentration values, one at each point in space.\nNow, we have to ask ourselves, is what we are seeing in both simulations truly what ideal diffusion predicts?\nVisually, both methods appear to show diffusion, but to be sure they simulate ideal diffusion, we need a quantitative measure.\nThere is one key property of diffusion that we can easily measure: the average squared distance of the distribution from the starting point, the mean squared displacement, grows proportionally with time.\nBy measuring the mean squared displacement, we can quantitatively compare the random walk and the numerical method.\nA basic comparison # For the random walk simulation, after each time step, we measure how far each walker is from the origin by squaring its displacement and summing them. For example, if \\(x_i\\) and \\(y_i\\) are the \\(x\\) and \\(y\\) positions of the \\(i^{\\text{th}}\\) walker, we do:\n$$ \\sum_{i}^N \\left((x_i - x_0)^2 + (y_i - y_0)^2\\right) $$where \\(N\\) is the total number of walkers and \\(x_0\\) and \\(y_0\\) are the origin positions.\nIf we did not square the displacements, then positive and negative displacements would cancel along the same axis. We are calculating how far the distribution spreads out from the origin; the direction shouldn\u0026rsquo;t matter. This value is then averaged across all walkers at the same time step to get:\n$$ \\frac{1}{N}\\sum_{i}^N \\left((x_i - x_0)^2 + (y_i - y_0)^2\\right) $$We repeat this process at every step to track how the spread evolves over time.\nThe same idea is applied in the numerical simulation. However, each grid point contributes both its distance from the origin and the concentration at that point. This means that after squaring the distance, we multiply it by the concentration at that same point. This acts like a weighting factor, so regions with more concentration influence the result more strongly:\n$$ \\frac{\\sum_{x,y} \\rho_{x,y}\\left((x - x_0)^2 + (y - y_0)^2\\right)}{\\sum_{x,y} \\rho_{x,y}} $$Notice how we have \\(\\sum_{x,y} \\rho_{x,y}\\) instead of \\(\\frac{1}{N}\\) in this case.\nIf we plot these measurements against time for each simulation method, we see that both follow a linear relationship. This is a defining property of ideal diffusion: the spread increases steadily rather than accelerating or slowing down, assuming there are no boundaries.\nClearly the slopes differ, however, this is due to differing initial conditions. In this case, the random walkers are set to travel at a greater distance per time step than what the diffusion coefficient of the equation model allows.\nSo how is it that particles in random motion are able to approximate diffusion?\nThe diffusion model # The Monte Carlo random walk and diffusion model are not independent. In fact, we can derive the diffusion equation from the random motion of a particle.\nMy simulation framework moves the random walkers continuously and then locks them into a discrete grid. For simplicity, we\u0026rsquo;ll assume the random walkers move discretely instead. In other words, we\u0026rsquo;ll assume this instead:\ndirection = getRandomDirection() if (direction == \u0026#34;Left\u0026#34;) : particleMoveToLeftCell() if (direction == \u0026#34;Right\u0026#34;) : particleMoveToRightCell() if (direction == \u0026#34;Up\u0026#34;) : particleMoveToTopCell() if (direction == \u0026#34;Down\u0026#34;) : particleMoveToBottomCell() Let\u0026rsquo;s assume a random walker lives on the following grid:\nWe\u0026rsquo;ll highlight the following region and make it our focus: Suppose we wanted to work out the probability of the walker being in \\((x,y)\\) at time \\(t + \\Delta t\\): We know that the probability of where the walker is now depends on where it was before. We know it could only have been in the left, right, top or bottom cell, at time \\( t \\). This means, from any one of those neighbouring cells, there is a \\(\\frac{1}{4}\\) chance of a walker entering \\(x, y\\) at time \\(t + \\Delta t\\).\nThis gives an equation we can start with: $$ P_{x,y}(t + \\Delta t) = \\frac{1}{4}(P(\\textbf{left cell } \\text{OR } \\textbf{right cell } \\text{OR } \\textbf{top cell } \\text{OR } \\textbf{bottom cell })) $$However, we know the walker could only have been in one of those four positions at time \\( t \\), but not all of them at once. In other words, all four possible positions are mutually exclusive: $$ P(\\textbf{left cell } \\text{OR } \\textbf{right cell } \\text{OR } \\textbf{top cell } \\text{OR } \\textbf{bottom cell }) = P_{x-1,y}(t) + P_{x+1,y}(t) + P_{x,y-1}(t) + P_{x,y+1}(t) $$This gives us the following equation: $$ P_{x,y}(t + \\Delta t) = \\frac{1}{4}\\left(P_{x-1,y}(t) + P_{x+1,y}(t) + P_{x,y-1}(t) + P_{x,y+1}(t)\\right) $$We want to convert this into the partial differential equation of the diffusion model. We know this implies a difference between two points. So let\u0026rsquo;s subtract \\(P_{x,y}(t)\\) from both sides: $$ P_{x,y}(t + \\Delta t) - P_{x,y}(t) = \\frac{1}{4}( P_{x+1,y}(t) + P_{x-1,y}(t) + P_{x,y+1}(t) + P_{x,y-1}(t) - 4P_{x,y}(t)) $$The \\(4P_{x,y}(t)\\) term in the right hand side cancels the \\(\\frac{1}{4}\\).\nCurrently, the equation is unitless. However, we can divide the left hand side by the time step to convert into probability per unit time, and the right hand side by the \\(\\Delta x^2 \\) and \\(\\Delta y^2 \\) to convert into probability per unit length squared:\n$$ \\frac{P_{x,y}(t + \\Delta t) - P_{x,y}(t)}{\\Delta t} \\Delta t = \\frac{1}{4}\\left( \\Delta x^2 \\frac{P_{x+1,y}(t) -2P_{x,y}(t) + P_{x-1,y}(t)}{\\Delta x^2} + \\Delta y^2\\frac{P_{x,y+1}(t) - 2P_{x,y}(t) + P_{x,y-1}(t)}{\\Delta y^2}\\right) $$You may have noticed that: $$\\frac{P_{x+1,y}(t) -2P_{x,y}(t) + P_{x-1,y}(t)}{\\Delta x^2}$$ and $$\\frac{P_{x,y+1}(t) - 2P_{x,y}(t) + P_{x,y-1}(t)}{\\Delta y^2}$$ are the discrete approximations for the second derivatives, \\(\\frac{\\partial^2 P}{\\partial x^2} \\) and \\(\\frac{\\partial^2 P}{\\partial y^2} \\).\nSimilarly, $$ \\frac{P_{x,y}(t + \\Delta t) - P_{x,y}(t)}{\\Delta t} $$ is the discrete approximation for \\(\\frac{\\partial P}{\\partial t} \\).\nIf we take the limit of \\(\\Delta t\\), \\(\\Delta x\\) and \\(\\Delta y\\) in the fractions as they approach \\(0\\), we can rewrite the equation as:\n$$ \\frac{\\partial P}{\\partial t} \\Delta t = \\frac{1}{4}\\left(\\Delta x^2 \\frac{\\partial^2 P}{\\partial x^2} + \\Delta y^2\\frac{\\partial^2 P}{\\partial y^2}\\right) $$Dividing by \\(\\Delta t\\) on both sides we get: $$ \\frac{\\partial P}{\\partial t}= \\frac{\\Delta x^2}{4 \\Delta t} \\frac{\\partial^2 P}{\\partial x^2} + \\frac{\\Delta y^2}{4 \\Delta t}\\frac{\\partial^2 P}{\\partial y^2} $$In this case, the diffusion coefficient is split into two: $$ D_x = \\frac{\\Delta x^2}{4 \\Delta t} $$ and $$ D_y = \\frac{\\Delta y^2}{4 \\Delta t} $$However, \\(\\Delta x\\) and \\(\\Delta y\\) are often made equal, such as in my simulation framework, and so we can set: $$ D = D_x = D_y $$ to get: $$ \\frac{\\partial P}{\\partial t}= D\\left(\\frac{\\partial^2 P}{\\partial x^2} + \\frac{\\partial^2 P}{\\partial y^2}\\right) $$Look familiar?\nWe\u0026rsquo;ve derived a model for a real-world thermodynamic process, all from the random and independent motion of particles.\nMore on diffusion # Ultimately, diffusion occurs from the kinetic collisions of an unimaginable number of particles. Naturally, this leads to particles spreading out over time as they occupy areas with fewer particles. The diffusion equation we calculated and use represents the overall concentrations of the particles, not their individual collisions.\nIn fact, with enough particles, we\u0026rsquo;ve shown that a random walk can approximate the average net displacement of diffusing particles.\nStatistically based simulations, such as the random walk, are useful for efficiently solving systems where a deterministic solution is more difficult or computationally expensive. That\u0026rsquo;s where Monte Carlo simulations, such as the random walk, are particularly useful.\nArticle Resources # Diffusion simulation framework github External Links # The mean squared displacement ","date":"29 November 2025","externalUrl":null,"permalink":"/articles/monte_carlo_diffusion/","section":"","summary":"","title":"2D diffusion with a Monte Carlo method","type":"article"},{"content":"","date":"29 November 2025","externalUrl":null,"permalink":"/tags/calculus/","section":"Tags","summary":"","title":"Calculus","type":"tags"},{"content":"","date":"29 November 2025","externalUrl":null,"permalink":"/tags/diffusion/","section":"Tags","summary":"","title":"Diffusion","type":"tags"},{"content":"","date":"29 November 2025","externalUrl":null,"permalink":"/tags/monte-carlo/","section":"Tags","summary":"","title":"Monte Carlo","type":"tags"},{"content":"","date":"29 November 2025","externalUrl":null,"permalink":"/tags/random-walk/","section":"Tags","summary":"","title":"Random Walk","type":"tags"},{"content":"","date":"29 November 2025","externalUrl":null,"permalink":"/tags/simulation/","section":"Tags","summary":"","title":"Simulation","type":"tags"},{"content":"","date":"29 November 2025","externalUrl":null,"permalink":"/tags/theory/","section":"Tags","summary":"","title":"Theory","type":"tags"},{"content":" The problem # 221B Baker Street is a fun board game.\nThe 221B Baker Street board game box. The goal is to identify the criminal, motive and weapon used in a crime. The first player to do so is the winner. Players take turns rolling a die and move around various places to look for clues. These clues are stored in a paper clue book.\nThe 221B Baker Street board game box. Unfortunately, searching through this clue book is a tedious process, as you can imagine. This is especially true with a high player count.\nSo how would you allow players to:\nsimultaneously have access to the clues reduce the time it takes to search for the right clue ensure each player does not read a clue longer than the allocated time? My solution is to design a web application where players can:\neach have a copy of the clues keep track of their reading time search for a clue by number instantly. All that is required on the part of the players is a wifi capable device with a browser.\nA quality-of-life improvement # Your browser does not support the video tag. That was the app. The music is a bit over the top, but I think it captures the sense of urgency pretty well.\nYou would\u0026rsquo;ve noticed a scanned page being displayed after the submit button was pressed. This is because the clues are a collection of scans from the physical clue book. There are 1050 clues in the book, stored within 86 pages.\nYes, I did have to scan the whole book, however, I scanned two pages at a time and digitally split them into two. This did not take too long, suprisingly. More importantly, this only needed to be done once.\nEach file was renamed to include the range of clues it held. For example, if a page held clues 1 to 30, it would be renamed to clue_1_30.jpg.\nTo identify the appropriate clue page given an input clue number, the web app extracts the clue range from the file name using simple regex, and checks if the input clue number is within the range.\nThere is the possibility of a clue spanning two pages, that is why the web app checks all the file names and does not stop at the first match. The web app could be improved by stopping after the second match, however, the performance is sufficient and optimisation isn\u0026rsquo;t really required for my use case.\nIn other words, once it was working, I didn\u0026rsquo;t modify the code for optimisation. My goal was to finish this project within a day. If it met all the requirements and was perfomant enough, it would be enough for me.\nLogic diagram # The logic flow of web app is simple.\nProject Resources # Web app github repository External Links # About the 221B Baker Street Board game ","date":"25 November 2025","externalUrl":null,"permalink":"/projects/baker_street_digital_clue_book/","section":"","summary":"","title":"221B Baker Street Digital Clue Book","type":"project"},{"content":"","date":"25 November 2025","externalUrl":null,"permalink":"/tags/css/","section":"Tags","summary":"","title":"CSS","type":"tags"},{"content":"","date":"25 November 2025","externalUrl":null,"permalink":"/tags/html/","section":"Tags","summary":"","title":"HTML","type":"tags"},{"content":"","date":"25 November 2025","externalUrl":null,"permalink":"/tags/javascript/","section":"Tags","summary":"","title":"Javascript","type":"tags"},{"content":"","date":"25 November 2025","externalUrl":null,"permalink":"/tags/quality-of-life/","section":"Tags","summary":"","title":"Quality-of-Life","type":"tags"},{"content":"","date":"25 November 2025","externalUrl":null,"permalink":"/tags/web-app/","section":"Tags","summary":"","title":"Web App","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]